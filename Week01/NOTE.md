### 跳表
##### 前言
      跳表是基于链表的; 
      链表的时间复杂度：增加 删除为o(1) ;   查找为o(n); 
      跳表是对链表的优化；
##### 特点
      链表元素是有序的；跳表中的元素必须是有序的
	    跳表对标是平衡树和二分查找；是一种插入 删除 查找 都是o(log n)的数据结构（redis、leveldb在用）
      
##### redis使用跳表而不使用红黑树原因
	    (1)skiplist的复杂度和红黑树一样，而且实现起来更简单。
	    (2)在并发环境下skiplist有另外一个优势，红黑树在插入和删除的时候可能需要做一些rebalance的操作，这样的操作可能会涉及到整个
	       树的其他部分，而skiplist的操作显然更加局部性一些，锁需要盯住的节点更少，因此在这样的情况下性能好一些

##### 思想
	    一维数据要加速的话，经常采用的方式就是升维，也就是一维变二维； 多了一层维度也就多一级多信息；
        
       
![097a704bf38491171e7c4104dc4371bb.png](evernotecid://BC9FE476-23F8-4CA8-8C4C-25BBA037D39A/appyinxiangcom/29568949/ENNote/p30?hash=097a704bf38491171e7c4104dc4371bb)

	要找8元素，则先从二级索引开始找，找到7和7之后的数，知道8在7之后，然后在从7开始找一级索引，发现8小于9，也就说8在7到9之间，然后再继续向下找原始链表。
    
   ##### 时间复杂度
	索引节点的个数；原始为一级索引则为n； 二级索引n/2; 三级索引n/8; … k级索引n/(2^k)
	假设有h级；最高索引有2个节点，则n/(2^h) = 2;  k = log n - 1;
	也就是说跳表查询节点的时间复杂度为o(log n)


### 递归

 
##### 代码模块
1. 递归结束条件 
2. 处理当前层逻辑 
3. 进到下一层 
4. 清理当前层

##### 思维要点
1. 不要人肉进行递归（最大误区）
2. 找最近重复子问题
3. 数学归纳法的思维


### 算法五毒神掌

第一遍， 看别人的解法，然后背诵默写比较好的解法
第二遍， 自己在记事本里写刚背的解法
第三遍， 第二天把前一天的题目重新做一遍，专项训练不熟练的题目
第四遍， 一周之后在重复做一遍，专项训练不熟练的题目
第五遍， 面试前一周把做过的题目再做一遍

刷题最大的误区就是刷题只刷一遍 
算法的核心思想：第一就是要升维 第二是用空间换时间

##### 懵逼的时候
	能否暴力求解？ 基本情况是什么？ 能不能化繁为简
	找最近、重复子问题 